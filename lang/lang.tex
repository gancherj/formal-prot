
\documentclass{article}
\usepackage{amsmath, amssymb, amsthm}
\usepackage{proof}
\usepackage{stmaryrd}
\usepackage{algorithm, algpseudocode}

\newcommand{\Val}{\mathsf{Val}}
\newcommand{\St}{\mathsf{St}}
\newcommand{\InBuf}{\mathsf{InBuf}}
\newcommand{\OutBuf}{\mathsf{OutBuf}}
\newcommand{\PID}{\mathsf{PID}}
\newcommand{\Var}{\mathsf{Var}}
\newcommand{\Handler}{\mathsf{Handler}}
\renewcommand{\list}{\mathsf{list}}
\newcommand{\D}{\mathcal{D}}
\newcommand{\NewEv}{\mathsf{NewEv}}
\newcommand{\OldEv}{\mathsf{OldEv}}
\newcommand{\Read}{\mathsf{read}}
\newcommand{\Write}{\mathsf{write}}
\newcommand{\send}{\mathsf{send}}
\newcommand{\recv}{\mathsf{recv}}



\title {Probabilistic Semantic Noninterference}
\begin{document}
\maketitle


\section{General Message Passing}
\subsection{Parties and Schedulers}

Assume an expression language with values in $\Val$. A \emph{state} $\St$ is a map $\Var \to (\Val + \bot)$, where $\Var$ is a set of variable names. A \emph{buffer} is a value of type $\list (\PID \times \Val)$, where $\PID$ is a set of party names.

A \emph{handler} is given by the following syntax:
\[ P := x \leftarrow \Read\ \ell \mid \Write\ \ell\ e \mid \send\ i\ e \mid x \leftarrow \recv\ i \mid x \leftarrow D\ e \mid \textsf{if } e \textsf{ then } P \textsf{ else } P \mid P; P, \]

where $e$ is an expression, $\ell$ is in $\Var$, $i$ is a PID, and $D$ is a set of distributions.

Handlers are given monadic semantics as functions $\St \to \InBuf \to \D(\St \times \OutBuf)$, where $\InBuf$ and $\OutBuf$ are both buffers. Messages in the input buffer are pairs $(i,m)$, where $m$ is the message content and $i$ is the PID the message came from. Messages in the output buffer, dually, are pairs $(i,m)$, where $i$ is the PID the message is meant for. This semantics is immediate, except for $\recv$, which returns the list of all messages from $i$ in the input buffer (in reverse chronological order).

A \emph{scheduler} is defined by the following syntax:
\[ c := \textsf{Run}\ P\ @\ i \mid c_1;\ c_2, \]

where $k \in \Handler$ is a handler name, and $i$ is a $\PID$.

\subsection{Semantics}

A \emph{trace} $\tau$ is a value of type $(\PID \to \St) \times \NewEv \times \OldEv$, where $\NewEv$ and $\OldEv$ are logs of the form $\list (\PID \times \PID \times \Val)$. The first component is the global state, the second component is ordered buffer of unprocessed messages, and the third component is the ordered buffer of processed messages. Given a buffer $B$, define $B_{| i}$ to be the pairs in $B$ such that the second component is equal to $i$ (preserving order).

Then, define our scheduler semantics $\llbracket c \rrbracket : \textsf{Trace} \to \D(\textsf{Trace})$ by

\[\llbracket \textsf{Run}\ P\ @\ i \rrbracket (G, B_u, B_p) := \textsf{bind}_{\D}\ (P\ (G\ i)\ B_{u_{| i}})\ (\lambda (s', o).\ \textsf{return}_{\D} (G[i := s'], o\ ||\ (B_u \setminus B_{u_{| i}}), B_{u_{| i}}\ ||\ B_p)\ \]

and

\[\llbracket c_1;\ c_2 \rrbracket\ \tau\ := \textsf{bind}_{\D}\ (\llbracket c_1 \rrbracket \tau) \llbracket c_2 \rrbracket.\]

where $\textsf{bind}_{\D}$ and $\textsf{return}_{\D}$ are the monadic bind and return operations for distributions and $||$ is list concatenation.

\subsection{Corruption}

Extend the syntax of schedulers as so:
\[ c := \dots \mid \textsf{Corrupt}\ P\ @\ i.\]

The semantics of the added command is exactly the same as that of \textsf{Run}.

We define (static) corruption by the following rewrite rules, given by the judgement $c \rightsquigarrow_{\mathcal{A}} c'$:

\begin{tabular}{cccc}
    $\infer{c \rightsquigarrow_{\mathcal{A}} c}{}$ & 
    $\infer{\textsf{Run}\ P\ @\ i \rightsquigarrow_{\mathcal{A}} \textsf{Corrupt}\ Q\ @\ i}{}$ &
    $\infer{c_1;c_2 \rightsquigarrow_{\mathcal{A}} c_1'; c_2'} {c_1 \rightsquigarrow_\mathcal{A} c_1' & c_2 \rightsquigarrow_\mathcal{A} c_2'}$ &
    $\infer{c \rightsquigarrow_{\mathcal{A}} c'; \textsf{Corrupt}\ Q\ @\ i}{c \rightsquigarrow_\mathcal{A} c'}$ \\
\end{tabular}

Then, define $\mathsf{crupt}(c)$ to be the set of parties $i \in \PID$ such that $\textsf{Corrupt}\ Q\ @\ i$ appears in $c$ for some $Q$.

(Note that adversarial programs do not share local state. However, they may freely pass messages to and from each other.)

\subsubsection{Other adversarial models}

Above, $\rightsquigarrow_\mathcal{A}$ models full malicious corruption. We may recover semihonest corruption (i.e., ordinary party-level noninterference without byzantine faults) by replacing $\rightsquigarrow_\mathcal{A}$ with the weakened rewrite rule:

\begin{tabular}{ccc}
    $\infer{c \rightsquigarrow_{\mathcal{S}} c}{}$ & 
    $\infer{\textsf{Run}\ P\ @\ i \rightsquigarrow_{\mathcal{S}} \textsf{Corrupt}\ P\ @\ i}{}$ &
    $\infer{c_1;c_2 \rightsquigarrow_{\mathcal{S}} c_1'; c_2'} {c_1 \rightsquigarrow_\mathcal{S} c_1' & c_2 \rightsquigarrow_\mathcal{A} c_2'}$ \\
\end{tabular}

In the above rule, we do not change the semantics of any party, but only mark certain parties for corruption. By marking only a single party for corruption, the above definition collapses to ordinary noninterference.

Additionally, we may restrict our corruption model with one that cannot corrupt any party at will, but only a certain subset of the parties. An example of this is \emph{honest-verifier zero knowledge}, where the prover is permitted to be malicious but the verifier is not.

\subsection{Noninterference}

A \emph{leakage} (or \emph{declassification}) property $\varphi$ is a function $\PID \to (\PID \to \St) \to \Val$. Given an initial global state $G$, $\varphi\ i\ G$ denotes the information $i$ should be able to learn from $G$ after the execution of the protocol. Given a set $T$ of PIDs, define $\varphi\ T\ G := \{(i, \varphi\ i\ G) \mid i \in T\}$.

Given two distributions $D$ on traces, write $D \equiv_i D'$ if the marginals $\mathcal{D} (\lambda\ G\ B_u\ B_p.\ (G\ i, B_{p_{| i}}))$ are identical for both $D$ and $D'$. That is, $D \equiv_i D'$ if from party $i$'s position, $D$ contains exactly the same information as $D'$ on both states and processed messages (including order of messages). Similarly lift up to sets of parties by defining $D \equiv_T D' := \wedge_{i \in T} D \equiv_i D'$.


Fix a corruption model $\rightsquigarrow$. Given global states $G$ and $G'$, define $G =_T G'$ to be $\forall i \in T, (G\ i) = (G'\ i).$ Then, say that $c$ is \emph{$\varphi$-noninterferent} if for all $c'$ such that $c \rightsquigarrow c'$ and global states $G, G'$, 
\[ G=_{\mathsf{crupt}(c')}G' \wedge\ \varphi\ \mathsf{crupt}(c')\ G = \varphi\ \mathsf{crupt}(c')\ G' \implies \llbracket c' \rrbracket\ (G, \emptyset, \emptyset) \equiv_{\mathsf{crupt}(c')} \llbracket c' \rrbracket\ (G', \emptyset, \emptyset).\]

That is, $c'$ is $\varphi$-noninterferent  if whenever two initial global states look identical to the adversary and agree on values of $\varphi$, then their induced final traces will appear identical to the adversary. 

Note that in the above definition, equivalence of traces is sensitive to order of message delivery -- but is only sensitive to message ordering from the perspective of individual parties. That is, two send commands in a handler may be safely reordered if they are sent to different recipients.


\subsection{Authenticity}

Let $\theta$ be a property of traces $\PID \to ((\PID \to \St) \times \NewEv \times \OldEv) \to \{0,1\}$, and let $\phi$ be a property of memories $\PID \to (\PID \to \St) \to \{0,1\}$. Lift $\phi$ and $\theta$ to operate on sets of $\PID$s by defining $\phi\ T\ G := \wedge_{i \in T} \phi\ i\ G$, and similarly for $\theta$.

Fix a corruption model $\rightsquigarrow$. Then $c$ is \emph{$(\epsilon, \theta, \phi)$-authentic} if for all $c'$ such that $c \rightsquigarrow c'$ and $G$,

\[ \Pr_{\tau \leftarrow (\llbracket c' \rrbracket\ (G, \emptyset, \emptyset))}[\theta\ \mathsf{crupt}(c')\ \tau] > \epsilon \implies \phi\ \mathsf{crupt}(c')\ G.\]

That is, $c$ is \emph{$(\epsilon, \theta, \phi)$-authentic} if whenever the adversary triggers the event $\theta$ with probability larger than $\epsilon$, then $\phi$ must be true of the adversary's initial state.


\subsection{Examples}


In \emph{multiparty computation}, each party is given an input $x_i$, and a protocol is devised so that each party receives the value $f(\vec{x})$, but no further information is shared. This is modeled by the leakage function $\phi\ i\ G := f((G\ 1).in, \dots, (G\ n).in)$.

Functions may also be asymmetric, in which the leakage function is $\phi\ i\ G := f_i((G\ 1).in, \dots, (G\ n).in)$. A canonical example is \emph{oblivious transfer}, where the sender has two messages $m_0$ and $m_1$, and the receiver has a bit $b$. The sender should learn nothing (i.e., $f_S (m_0, m_1, b) = ()$), while the receiver should learn the $b$th message (i.e., $f_R (m_0, m_1, b) := \text{if}\ b \text{ then } m_0 \text{ else } m_1.$)


We may define \emph{zero-knowledge} proofs to be authentic relative to the predicates ``the verifier output 1'' and ``the prover has a correct witness $w$ to the NP-statement $x$'', and noninterferent relative to the leakage function ``$R(x,w) = 1$'' for the verifier, and no leakage for the prover. 


\section{Session-restricted Parties}

Here, we will consider parties and adversaries which are assumed to follow the protocol's intended session structure. 

Let $\St$ be as before. The type $\mathsf{Party}\ M\ M'$ is defined to be functions $\St \to M \to \D(\St \times M')$. Parties are given by the following syntax:

\[ P := x \leftarrow \Read\ \ell \mid \Write\ \ell\ e \mid \send\ e \mid x \leftarrow \recv\ \mid x \leftarrow D\ e \mid \textsf{if } e \textsf{ then } P \textsf{ else } P \mid P; P, \]

where $\recv$ evaluates to the current input message, and $\send$ alters the intended output message. (I.e., a second invocation of $\send$ will overwrite the first one.) Parties come with a typing relation $\vdash P : \mathsf{Party}\ M\ M'$, which says that all receives and sends respect $M$ and $M'$.


Schedulers have the same syntax as before:

\[ c := \textsf{Run}\ P\ @\ i \mid \textsf{Corrupt}\ P\ @\ i \mid c; c\]

Schedulers are well-typed when they respect the sessions of the parties:

    \begin{tabular}{cccc}
        $\infer{\vdash \textsf{Run}\ P\ @\ i : \textsf{Sched}\ M\ M'}{\vdash P : \mathsf{Party}\ M\ M'}$ &
        $\infer{\vdash \textsf{Corrupt}\ P\ @\ i : \textsf{Sched}\ M\ M'}{\vdash P : \mathsf{Party}\ M\ M'}$ &
        $\infer{\vdash c; c' : \textsf{Sched}\ M\ M'}{\vdash c : \textsf{Sched}\ M\ M'' & \vdash c' : \textsf{Sched}\ M''\ M'}$ &
        \ \\
    \end{tabular}

A scheduler is \emph{runnable} if it has type $\textsf{Sched}\ \textsf{unit}\ M$, for some $M$.

\subsection{Semantics}


As before, a global state is a map $\PID \to \St$. A \emph{trace} is a value of type $(\PID \to \St) \times \list (\PID \times \Val)$.

Commands are given as mappings from traces to distributions over traces:

\begin{align*}
    \llbracket \textsf{Run}\ P\ @\ i \rrbracket (G, m :: \tau) &:= \mathsf{bind} (P\ (G\ i)\ m) (\lambda (S, m').\ \mathsf{return}\ (G[i := S], m' :: m :: \tau)) \\
    \text{(Same for \textsf{Corrupt})} \\
    \llbracket c; c' \rrbracket (G, \tau) &:= \mathsf{bind} (\llbracket c \rrbracket (G, \tau)) \llbracket c' \rrbracket
\end{align*}

\subsection{Corruption}

Given a set of PIDs $T$, define

\begin{tabular}{ccc}
    $\infer{c \rightsquigarrow c}{}$ &
    $\infer{\textsf{Run}\ P\ @\ i \rightsquigarrow \textsf{Corrupt}\ Q\ @\ i}{\vdash P : \textsf{Party}\ M\ M' & \vdash Q : \textsf{Party}\ M\ M' & i \in T}$ &
    $\infer{c_1; c_2 \rightsquigarrow c'_1; c'_2}{c_1 \rightsquigarrow c'_1 & c_2 \rightsquigarrow c'_2}$
\end{tabular}


As before, define $\mathsf{crupt}(c)$ to be the set of parties in $c$ that are corrupted.

\subsection{Trace properties}

Trace properties for this language are essentially the same as before: given a trace $\tau$ and a set of PIDs $T$, define $\tau_{| T}$ to be $T$'s visible part of $\tau$. Then, $c$ is $\varphi$-noninterferent if it is runnable and for all $c'$ such that $c \rightsquigarrow c'$ and global states $G$ and $G'$,

\[ G=_{\mathsf{crupt}(c')}G' \wedge\ \varphi\ \mathsf{crupt}(c')\ G = \varphi\ \mathsf{crupt}(c')\ G' \implies \llbracket c' \rrbracket\ (G, [()]) \equiv_{\mathsf{crupt}(c')} \llbracket c' \rrbracket\ (G', [()]).\]

Similarly, $c$ is \emph{$(\epsilon, \theta, \phi)$-authentic} if for all $c'$ such that $c \rightsquigarrow c'$ and $G$,
\[ \Pr_{\tau \leftarrow (\llbracket c' \rrbracket\ (G, [()]))}[\theta\ \mathsf{crupt}(c')\ \tau] > \epsilon \implies \phi\ \mathsf{crupt}(c')\ G,\]

where $\theta : \PID \to (\PID \to \St) \times \list (\PID \times \Val) \to \{0,1\}$, and $\phi : \PID \to (\PID \to \St) \to \{0,1\}$.



\end{document}
